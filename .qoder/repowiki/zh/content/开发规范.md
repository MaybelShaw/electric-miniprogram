# 开发规范

<cite>
**本文档引用的文件**  
- [pyproject.toml](file://backend/pyproject.toml)
- [commitlint.config.mjs](file://frontend/commitlint.config.mjs)
- [.eslintrc](file://frontend/.eslintrc)
- [tsconfig.json](file://frontend/tsconfig.json)
- [stylelint.config.mjs](file://frontend/stylelint.config.mjs)
- [users/models.py](file://backend/users/models.py)
- [product.ts](file://frontend/src/services/product.ts)
- [api.ts](file://merchant/src/services/api.ts)
- [logging_config.py](file://backend/common/logging_config.py)
- [exceptions.py](file://backend/common/exceptions.py)
</cite>

## 目录
1. [代码风格规范](#代码风格规范)
2. [提交规范](#提交规范)
3. [代码审查流程](#代码审查流程)
4. [测试规范](#测试规范)

## 代码风格规范

### Python代码风格

本项目后端采用Python 3.12+开发，遵循PEP 8代码风格规范。通过`pyproject.toml`文件配置项目依赖和元数据，确保代码的一致性和可维护性。

Python代码应遵循以下规范：
- 使用4个空格进行缩进
- 每行代码不超过79个字符
- 函数和类定义之间用两个空行分隔
- 模块级常量使用大写字母和下划线命名
- 类名采用PascalCase命名法
- 函数和变量名采用snake_case命名法
- 使用空行分隔逻辑代码块
- 所有导入语句放在文件顶部
- 模块导入按标准库、第三方库、本地库的顺序分组

**Section sources**
- [pyproject.toml](file://backend/pyproject.toml)
- [users/models.py](file://backend/users/models.py)

### TypeScript代码风格

前端项目采用TypeScript进行类型安全的开发，主要遵循以下规范：

#### 接口命名规范
- 接口名称使用PascalCase命名法
- 接口名称以大写字母"I"开头（如`IUser`）
- 类型别名使用PascalCase命名法
- 组件Props接口以"Props"结尾（如`UserProfileProps`）
- 组件State接口以"State"结尾（如`UserProfileState`）

#### 类型定义规范
- 明确指定所有变量和函数的类型
- 使用联合类型表示多种可能的值
- 使用可选属性（?）表示可为空的字段
- 使用readonly修饰符表示不可变属性
- 为API响应定义明确的接口类型

#### ESLint配置
项目使用ESLint进行代码质量检查，配置文件位于`.eslintrc`，主要配置如下：
- 继承`taro/react`配置
- 禁用`react/jsx-uses-react`和`react/react-in-jsx-scope`规则
- 使用`eslint-config-taro`作为基础配置
- 集成`@typescript-eslint/eslint-plugin`进行TypeScript支持

#### TypeScript配置
`tsconfig.json`文件配置了TypeScript编译选项：
- 目标为ES2017
- 模块系统为CommonJS
- 启用严格空值检查
- 启用装饰器支持
- 配置路径别名`@/*`指向`src/*`

**Section sources**
- [.eslintrc](file://frontend/.eslintrc)
- [tsconfig.json](file://frontend/tsconfig.json)
- [product.ts](file://frontend/src/services/product.ts)
- [api.ts](file://merchant/src/services/api.ts)

### CSS/Sass规范

前端样式使用Sass预处理器，遵循以下规范：
- 使用BEM命名方法（Block__Element--Modifier）
- 变量名使用kebab-case命名法
- 混合宏（mixin）名称使用camelCase命名法
- 避免使用ID选择器
- 限制选择器嵌套层级不超过3层
- 使用语义化的类名

项目使用Stylelint进行CSS代码检查，配置文件`stylelint.config.mjs`继承`stylelint-config-standard`标准配置。

**Section sources**
- [stylelint.config.mjs](file://frontend/stylelint.config.mjs)

## 提交规范

### 提交消息验证

项目使用`commitlint`工具验证提交消息格式，确保提交历史的可读性和一致性。配置文件`commitlint.config.mjs`继承了`@commitlint/config-conventional`配置，遵循Angular提交规范。

```javascript
export default { extends: ["@commitlint/config-conventional"] };
```

提交消息必须遵循以下格式：
```
<type>(<scope>): <subject>
<BLANK LINE>
<body>
<BLANK LINE>
<footer>
```

### 提交类型规范

提交类型（type）必须从以下列表中选择：
- **feat**: 新功能
- **fix**: 修复bug
- **docs**: 文档更新
- **style**: 代码格式调整（不影响代码运行）
- **refactor**: 代码重构（既不修复bug也不增加新功能）
- **perf**: 性能优化
- **test**: 增加或修改测试
- **chore**: 构建过程或辅助工具的变动
- **build**: 影响构建系统的更改
- **ci**: 持续集成相关更改
- **revert**: 回滚提交

### 提交范围规范

提交范围（scope）应描述受影响的模块或功能，如：
- `users`: 用户模块
- `catalog`: 商品目录模块
- `orders`: 订单模块
- `auth`: 认证模块
- `frontend`: 前端相关
- `backend`: 后端相关
- `merchant`: 商户管理后台

### 提交消息示例

正确的提交消息示例：
```
feat(users): 添加用户地址管理功能

- 实现用户收货地址的增删改查
- 添加地址验证逻辑
- 优化地址选择UI

Closes #123
```

```
fix(catalog): 修复商品搜索结果不准确问题

- 修正搜索关键词匹配逻辑
- 优化数据库查询性能
- 添加搜索结果缓存

Fixes #456
```

```
refactor(orders): 重构订单状态机逻辑

- 将订单状态流转逻辑提取到独立服务
- 增加状态转换验证
- 提高代码可测试性
```

### Git Hooks配置

项目使用Husky配置Git Hooks，在提交前自动运行验证：
- `pre-commit`: 运行lint-staged，对暂存文件进行代码格式化和检查
- `commit-msg`: 使用commitlint验证提交消息格式
- `pre-push`: 运行测试套件

这些配置确保只有符合规范的代码才能提交到版本库。

**Section sources**
- [commitlint.config.mjs](file://frontend/commitlint.config.mjs)
- [package.json](file://frontend/package.json)

## 代码审查流程

### 审查原则

代码审查应遵循以下原则：
- **建设性反馈**: 提供建设性的改进建议，避免批评性语言
- **关注重点**: 重点关注代码正确性、性能、安全性和可维护性
- **保持一致**: 确保代码风格与项目现有代码一致
- **知识共享**: 通过审查过程分享知识和最佳实践
- **及时反馈**: 在合理时间内完成审查，避免阻塞开发进度

### 审查检查清单

审查者应检查以下方面：

#### 功能正确性
- 代码是否实现了预期功能
- 是否处理了所有边界情况
- 错误处理是否恰当
- 是否有潜在的空指针或类型错误

#### 代码质量
- 代码是否清晰易懂
- 是否有重复代码
- 函数和类的职责是否单一
- 变量和函数命名是否恰当
- 是否有足够的注释说明复杂逻辑

#### 性能考虑
- 是否有不必要的数据库查询
- 是否有潜在的性能瓶颈
- 缓存策略是否合理
- 是否有内存泄漏风险

#### 安全性
- 是否有SQL注入风险
- 是否有XSS攻击风险
- 敏感信息是否妥善处理
- 权限控制是否正确

#### 测试覆盖
- 是否有足够的单元测试
- 测试用例是否覆盖主要场景和边界情况
- 测试代码是否清晰易懂
- 是否有冗余的测试

#### 可维护性
- 代码是否易于扩展
- 是否有良好的模块化设计
- 依赖关系是否合理
- 配置是否易于管理

### 审查流程

1. **创建Pull Request**: 开发者完成功能开发后，创建Pull Request并关联相关任务
2. **自动检查**: CI系统自动运行代码检查、格式化和测试
3. **分配审查者**: 根据代码涉及的模块，分配相应的审查者
4. **审查反馈**: 审查者在24小时内提供反馈，使用"建议"功能提出具体修改建议
5. **修改代码**: 开发者根据反馈修改代码并回复评论
6. **批准合并**: 当所有问题解决且自动检查通过后，审查者批准PR
7. **合并代码**: 开发者将代码合并到主分支

### 最佳实践

- **小批量提交**: 每个PR应聚焦于单一功能或修复，避免过大
- **清晰描述**: PR描述应清楚说明变更目的、实现方式和影响范围
- **关联任务**: 将PR与项目管理工具中的任务关联
- **及时沟通**: 对审查意见有疑问时，及时沟通澄清
- **学习改进**: 从审查反馈中学习，避免重复问题

**Section sources**
- [DEVELOPER_GUIDE.md](file://DEVELOPER_GUIDE.md)

## 测试规范

### 单元测试

#### 覆盖率要求
- 核心业务逻辑代码覆盖率不低于80%
- 公共工具函数代码覆盖率不低于90%
- 新增代码必须有相应的测试覆盖

#### 测试编写指南
- 使用描述性测试名称，清晰表达测试目的
- 遵循AAA模式（Arrange-Act-Assert）
- 每个测试只验证一个关注点
- 使用测试数据构建器创建测试数据
- 避免测试之间的依赖
- 使用mock隔离外部依赖

#### Python测试示例
```python
def test_create_user_with_openid():
    """测试使用openid创建用户"""
    # Arrange
    openid = "test_openid_123"
    
    # Act
    user = User.objects.create_user(openid=openid)
    
    # Assert
    assert user.openid == openid
    assert user.user_type == "wechat"
    assert user.is_active is True

def test_update_user_address():
    """测试更新用户地址"""
    # Arrange
    user = User.objects.create_user(openid="test_openid")
    address = Address.objects.create(
        user=user,
        contact_name="张三",
        phone="13800138000",
        province="北京市",
        city="北京市",
        district="朝阳区",
        detail="建国路1号"
    )
    
    # Act
    address.contact_name = "李四"
    address.save()
    
    # Assert
    updated_address = Address.objects.get(id=address.id)
    assert updated_address.contact_name == "李四"
```

#### TypeScript测试示例
```typescript
describe('productService', () => {
  it('should get product list successfully', async () => {
    // Arrange
    const mockResponse = {
      results: [
        { id: 1, name: '测试商品', price: 100 },
        { id: 2, name: '另一个商品', price: 200 }
      ],
      total: 2,
      page: 1,
      total_pages: 1
    };
    mockHttp.get.mockResolvedValue(mockResponse);
    
    // Act
    const result = await productService.getProducts();
    
    // Assert
    expect(result).toEqual(mockResponse);
    expect(mockHttp.get).toHaveBeenCalledWith('/products/', undefined, false);
  });
  
  it('should get product detail by id', async () => {
    // Arrange
    const productId = 1;
    const mockProduct = { id: productId, name: '测试商品', price: 100 };
    mockHttp.get.mockResolvedValue(mockProduct);
    
    // Act
    const result = await productService.getProductDetail(productId);
    
    // Assert
    expect(result).toEqual(mockProduct);
    expect(mockHttp.get).toHaveBeenCalledWith(`/products/${productId}/`, undefined, false);
  });
});
```

### 集成测试

#### 测试范围
- API端点的功能正确性
- 数据库交互的正确性
- 外部服务集成的正确性
- 业务流程的完整性

#### 测试策略
- 使用测试数据库隔离测试数据
- 模拟外部API调用
- 测试各种HTTP状态码和错误情况
- 验证响应格式和数据结构

### 测试组织

#### 目录结构
测试文件应与源代码保持相同的目录结构，测试文件以`_test.py`或`.test.ts`结尾：
```
backend/
├── users/
│   ├── models.py
│   ├── models_test.py
│   ├── views.py
│   └── views_test.py
frontend/
├── src/
│   ├── services/
│   │   ├── product.ts
│   │   └── product.test.ts
```

#### 测试数据管理
- 使用工厂模式创建测试数据
- 在测试前后清理测试数据
- 使用测试专用的配置
- 避免使用生产环境数据

### 测试运行

#### 本地运行
```bash
# 后端测试
python manage.py test

# 前端测试
npm run test
```

#### CI/CD集成
测试将在CI/CD流水线中自动运行：
- 提交代码时运行单元测试
- PR合并前运行完整测试套件
- 定期运行性能测试和安全扫描

**Section sources**
- [users/models.py](file://backend/users/models.py)
- [product.ts](file://frontend/src/services/product.ts)
- [logging_config.py](file://backend/common/logging_config.py)
- [exceptions.py](file://backend/common/exceptions.py)